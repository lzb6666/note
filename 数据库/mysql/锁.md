在官方文档中，提到了几种锁，包括：共享锁（读）、排它锁（写）、意向共享锁
、意向排他锁、记录锁、间隙锁、下一键锁、插入意向锁和自增锁；  
这些锁只是从不同的角度来看，分为了不同的种类；实际上它们之间有着联系。  
### 读写锁
在除串行化的隔离级别下，delete、update、insert都会带写锁，因为隐藏列的原
因，总是会锁住索引，实现行级锁，锁住要更新的行；
### 意向锁
意向锁是表级别的锁，主要作用是 **The main purpose of intention locks is to
 show that someone is locking a row, or going to lock a row in the table.**  
 
 即：当有行锁锁住某行时，当有其他事务想要申请表锁，就不需要去检查某个索引
 被锁，而是直接根据意向锁判断有事务正在锁定行；  
 
 加行锁过程：先加意向锁，再加行锁  
 
 意向锁也分写锁和读锁，和普通的写锁和表锁之间的冲突关系为：意向锁之间不
 冲突，写和任何锁冲突，读读之间不冲突；
 
### 记录锁
 记录锁就是锁在索引（由于隐藏行的存在总是有索引可以锁）上的行锁，可以避
 免被锁住的行被其他事务修改，记录锁其实就是行锁的实现；  
### 间隙锁
间隙锁只在可重复读隔离级别有效，能够避免当前读出现幻读的情况；通过锁住索引
之间的间隙不允许插入从而避免幻读；
### 下一键锁
下一键锁是记录锁和间隙锁合并起来的称呼，只是由于通常需要将记录锁和间隙锁
结合起来使用，进而有了下一键锁；  
同样下一键锁也只作用于可重复读级别
### 自增锁
自增锁是为了避免同一事务中产生的自增主键不连续的问题而定义的锁；显然它是
一种表锁，为了保持主键的连续会显著影响插入效率。  
### 插入意向锁
假设当前间隙锁锁定了索引4到7之间，另有两个事务分别要插入5和6，那么这两个
事务都首先要获得插入意向锁，在间隙锁取消后，二者可以同时插入；而不必串行
执行插入；  
insert values of 5 and 6, respectively, each lock the gap between 4 and 
7 with insert intention locks prior to obtaining the exclusive lock on 
the inserted row, but do not block each other because the rows are nonconflicting.